随着APP的发展，功能也会越来越丰富，代码急剧膨胀、编译速度慢，代码耦合、牵一发而动全身，这些问题都严重影响开发效率和项目的稳定性。这时候组件化和插件化就会派上用场。本篇文章是根据我们团队组件化的经历，介绍一些组件化的知识和相关问题的解决方案。

目录：

1.插件化和组件化的区别
2.为什么用组件化
3.组件化结构
	3.1 项目层级结构
	3.2 依赖管理
	3.3 工程建设
4. 组件化的问题及相关解决方案
    1）组件形式
    2）资源冲突
    3）组件通信 
    4）页面跳转
    5）组件版本管理
    6）分支管理


### 1.组件化和插件化的区别
插件化强调结果，允许功能模块以插件的形式，不需要预先打包到apk里，而是运行时在合适的时机动态加载进来。
组件化体现过程，更像是一种开发模式，不同功能模块的代码做物理隔离，比如分到不同的module或project中。组件化不具备插件化运行时动态加载的特性。

### 2. 为什么要用组件化
1）高效：因为每个组件都是一个独立的app，可以独立运行，所以开发人员只需要在自己的组件中开发测试即可，开发效率更高，编译速度更快
2）稳定：每个组件都是高内聚的模块，可以进行单元测试；一个组件代码发生变化，基本上也不会影响其他组件；

### 3. 组件化结构

##### 3.1 项目层级结构

每个团队对自己项目的层级划分都不太一样，粗略的说，可以分成下面三层：
基础业务层
业务支撑层
公共层

其中，
基础业务层：每个app的业务的部分，比如feed流、个人中心、登录注册等等
业务支撑层：比如用户Session、AB框架、打点、配置中心
公共层：比如图片、网络、UI基础组件、资源


##### 3.2 依赖管理

为了防止组件间循环依赖，组件依赖时要遵循一个原则：同一层的组件之间不能产生依赖，上层可以对下层组件产生依赖。

依赖方式参考：

gralde 3.0以上 | gradle 2.x | 说明
------- | ------- | -------
implementation | compile | 编译期间只对直接依赖的组件可见，在运行期间所有组件可见
api | compile | 编译期，运行期对所有组件可见
compileOnly | provided | 只参与编译不打包到apk
runtimeOnly | apk | 编译期间不可见，会打包到apk

对于implemention，假如模块A依赖模块B，模块B依赖模块C，即A->B->C，编译期间A不能访问C，当C修改时，gradle只会重新编译B，不会编译A。

##### 3.3 工程建设
项目大了，开发人员也会变多，一些基础设施和自动化的工具也有搭建起来。这里列举一些常用的： 
git、分支管理、持续集成（CI）、静态编译、lint、快速打包、灰度发布、bugly、协议文档等等。当然，实现插件化的，还有插件管理平台。 


### 4. 组件化的问题及相关解决方案
组件化之后，很多代码不在一个项目里，没办法直接通信、引用代码，相关问题随之而来。

##### 4.1 组件形式

组件可以做是一个独立的project，也可以放到一个项目中，以module形式存在。
如果把组件做成一个project，可以给project建app和library两个module，其中app模块是为了组件独立运行，library才是组件的真身，给其他组件提供依赖。
我们都知道，一个module是Android Library还是Application，取决于build.gradle中apply plugin的方式。
如果把组件做成主项目中的一个module，如果要组件独立运行，需要apply plugin为com.andorid.application，如果要以组件提供对外依赖，则要修改为com.android.library。
可以用条件变量对apply的形式做管理，业界也有更优雅的修改方式，但基本上绕不开这个套路。
```
if (isModule) {
	apply plugin: 'com.android.library'
} else {
	apply plugin: 'com.andorid.application'
}
```
每次切换，都需要重新gradle async，效率会打折扣。并且每次让开发人员手动操作，总避免不了哪天手抖犯错误。所以，还是建议采用第一种方法。

##### 4.2 资源冲突
不同组件有同名资源时，当组件打包到一起，就会产生资源冲突问题。
解决方法是，在build.gradle中添加资源前缀：
```
resourcePrefix 'module-a'
```
这种做法IDE并不会对资源重命名，而是做了lint检查。开发人员需要手动为资源添加前缀。

##### 4.3 组件间通信


##### 4.4 页面跳转

##### 4.5 组件版本管理


##### 4.6 分支管理
参考git flow流程。

