### 哪些内存需要回收
[Java的内存区域](./Java的内存区域.md)中介绍了Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。

栈中的栈帧随着方法的进入和退出而有条不紊地执行值出栈和入栈的操作。每一个栈帧中分配多少内存基本上是在类结构确定下来就已知的，大体上认为这部分内存时编译器可知的。这部分内存在方法结束或者线程结束时就自动回收了。

而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，Java中GC关注的就是这部分内存。

### 内存什么时候回收
> 分为Java堆的内存回收和方法区的内存回收
#### Java堆的内存回收
Java堆中存放的几乎是所有对象的实例，GC回收这部分内存前，需要判断这些对象的存活状态。

##### 对象存活判定算法

> 概念：引用的四种类型
* 强引用（StrongReference）
  * 具有强引用的对象不会被GC；
  * 即便内存空间不足，JVM宁愿抛出OutOfMemoryError使程序异常终止，也不会随意回收具有强引用的对象。
* 软引用（SoftReference）
  * 只具有软引用的对象，会在内存空间不足的时候被GC，如果回收之后内存仍不足，才会抛出OOM异常；
  * 软引用常用于描述有用但并非必需的对象，比如实现内存敏感的高速缓存。
* 弱引用（WeakReference）
  * 只被弱引用关联的对象，无论当前内存是否足够都会被GC；
  * 强度比软引用更弱，常用于描述非必需对象。
* 虚引用（PhantomReference）
  * 仅持有虚引用的对象，在任何时候都可能被GC
  * 常用于跟踪对象被GC回收的活动；
  * 必须和引用队列 （ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

##### a. 引用计数法
定义：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

> 然而在主流的Java虚拟机里未选用引用计数算法来管理内存，主要原因是它难以解决对象之间相互循环引用的问题，所以出现了另一种对象存活判定算法。

##### b.可达性分析法
定义：通过一系列被称为『GC Roots』的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

> 可作为GC Roots的对象
> * 虚拟机栈中引用的对象，只要是指栈中的``本地变量``
> * 本地方法栈中的``Native方法``引用的对象
> * 方法区中``类静态属性``引用的对象
> * 方法区中``常量``引用的对象

//TODO 
![image](https://raw.githubusercontent.com/JasonGaoH/Images/master/gc_roots.png)

需要注意的是，在可达性分析算法中被判定不可达的对象还未真的判『死刑』，至少要经历两次标记过程：判断对象是否有必要执行finalize()方法；若被判定为有必要执行finalize()方法，之后还会对对象再进行一次筛选，如果对象能在finalize()中重新与引用链上的任何一个对象建立关联，将被移除出“即将回收”的集合。

#### 方法区的回收
方法区在HotSpot虚拟机中被称为永久代。
永久代的垃圾收集主要回收两部分内存：废弃常量和无用的类。
##### a.废弃常量的回收
与回收Java堆中的对象的GC很类似，即在任何地方都未被引用的常量会被GC。

##### b.无用的类回收
无用的类需满足一下三个条件才会被GC：
* 该类所有的实例都已被回收，即Java堆中不存在该类的任何实例；
* 加载该类的ClassLoader已经被回收；
* 该类对应的java.lang.Class对象没在任何地方被引用，即无法在任何地方通过反射访问该类的方法。

### 内存如何回收
如何回收也就是谈到垃圾回收算法：

##### 垃圾收集算法

https://www.jianshu.com/p/a62697f00b85