### HTTP与HTTPS有什么区别.md

HTTPS 是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

HTPPS 和 HTTP 的概念:

HTTPS(全称:Hypertext Transfer Protocol over Secure Socket Layer)，是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL， 因此加密的详细内容就需要 SSL。它是一个 URI scheme(抽象标识符体系)，句法类同 http: 体系。用于安全的 HTTP 数据传输。https:URL 表明它使用了 HTTP，但 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层(在 HTTP 与 TCP 之间)。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。

超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服 务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。

HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费。HTTP 是超文本传输协议， HTTPS 则是具有安全性的 SSL 加密传输协议 HTTP 和 HTPPS 使用的是完全不 同的连接方式用的端口也不一样,前者是 80,后者是 443。HTTP 的连接很简单,是无状态的 HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议要比 HTTP 协议安全 

HTTPS 解决的问题:
1. 信任主机的问题. 采用 HTTPS 的 Server 必须从 CA 申请一个用于证明服务器用途类型的证书. 改证书只有用于对应的 Server 的时候,客户度才信任次主机；
2. 防止通讯过程中的数据的泄密和被窜改

HTTP 与 HTTPS 在写法上的区别也是前缀的不同，客户端处理的方式也不同，具体说来:
如果 URL 的协议是 HTTP，则客户端会打开一条到服务端端口 80(默认)的连接，并向其发送老的 HTTP 请求。 如果 URL 的协议是 HTTPS，则客户端会打开一条到服务端端口 443 (默认)的连接，然后与服务器握手，以二进制格式与服务器交换一些 SSL 的安全参数，附上加密的 HTTP 请求。 

所以你可以看到，HTTPS 比 HTTP 多了一层与 SSL 的连接，这也就是客户端与服务端 SSL 握手的过程，整个过程主要完成以下工作:交换协议版本号 选择一个两端都了解的密码 对两端的身份进行认证 生成临时的会话密钥，以便加密信道。 

SSL 握手是一个相对比较复杂的过程，更多关于 SSL 握手的过程细节 可以参考 TLS/SSL 握手过程。
SSL/TSL 的常见开源实现是 OpenSSL，OpenSSL 是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被 应用在互联网的网页服务器上。 更多源于 OpenSSL 的技术细节可以参考 OpenSSL。


### HTTP1.0和HTTP1.1的一些区别

HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络 请求上，而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的 HTTP 协议。 

主要区别主要体现在:

1. 缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做 为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag， If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓 存策略。
2. 带宽优化及网络连接的使用，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分， 即返回码是 206(Partial Content)，这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. 错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409(Conflict) 表示请求的资源与资源的当前状态发生冲突;410(Gone)表示服务器上的某个资 源被永久性的删除。
4. Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此,请求消息中的 URL 并没有传递主机名(hostname)。但随着虚拟主机技术的发展， 在一台物理服务器上可以存在多个虚拟主机(Multi-homed Web Servers)，并且它
们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误(400 Bad Request)。
5、长连接，HTTP 1.1 支持长连接(PersistentConnection)和请求的流水线 (Pipelining)处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection: keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。

### SPDY

在讲 Http1.1 和 Http2.0 的区别之前，还需要说下 SPDY，它是 HTTP1.x 的优化方案: 2012 年 google 如一声惊雷提出了 SPDY 的方案，优化了 HTTP1.X 的请求延迟，解决了
HTTP1.X 的安全性，具体如下:

1. 降低延迟，针对 HTTP 高延迟的问题，SPDY 优雅的采取了多路复用(multiplexing)。 多路复用通过多个请求 stream 共享一个 tcp 连接的方式，解决了 HOL blocking 的 问题，降低了延迟同时提高了带宽的利用率。
2. 请求优先级(request prioritization)。多路复用带来一个新的问题是，在连接 共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先 级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 html 内容应 该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能 第一时间看到网页内容。
3. header 压缩。前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适 的压缩算法可以减小包的大小和数量。
4. 基于 HTTPS 的加密协议传输，大大提高了传输数据的可靠性。
5. 服务端推送(server push)，采用了 SPDY 的网页，例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户 端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。

SPDY 位于 HTTP 之下，TCP 和 SSL 之上，这样可以轻松兼容老版本的 HTTP 协议(将 HTTP1.x 的内容封装成一种新的 frame 格式)，同时可以使用已有的 SSL 功能。

### HTTP2.0和HTTP1.X相比的新特性

1. 新的二进制格式(Binary Format)，HTTP1.x 的解析是基于文本。基于文本协议的 格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然 很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定 采用二进制格式，实现方便且健壮。
2. 多路复用(MultiPlexing)，即连接共享，即每一个 request 都是是用作连接共享机 制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属 到各自不同的服务端请求里面。
3. header 压缩，如上文中所言，对前面提到过 HTTP1.x 的 header 带有大量信息，而 且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯 双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需 要传输的大小。
4. 服务端推送(server push)，同 SPDY 一样，HTTP2.0 也具有 server push 功能。

问题：

1. HTTPS环境下，能否使用ip通信？
2. HTTPS环境下，修改系统时间，能够正常通信？

因为HTTPS通信，会在客户端安装一个数字证书，IO时，会校验通信信息是否符合证书里的内容。
问题1中，因为证书会校验域名，但是ip没有域名，所以直接使用ip是无法通信的。
问题2中，因为证书会校验有效期，客户端修改系统时间可能使得改后的时间超过证书有效期，就会无法通过校验，故而无法通信。