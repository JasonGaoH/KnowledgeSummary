# 线程安全

线程安全：多线程环境中，能够确保共享变量的正确使用。

当然实际开发多线程功能时，我们需要同时关注原子性、可见性、顺序性。

* 原子性
* 可见性
* 顺序性

### 原子性
一个操作（可能包含多个子操作）不可以被中断。

##### 如何保证原子性

使用锁和同步。

常见的保证Java操作原子性的方式是加锁，或者对方法、代码块进行同步。

```
public void lock() {
	obj.lock();
	...
    obj.unlock();
}
```

```
public synchronized void syncMethod() {
	...
}


public void syncMethod2() {
	synchronized(obj) {
		...
	}
}
```

无论使用锁还是synchronized，本质都是一样，通过锁来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。


### 可见性

当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。

##### 如何保证可见性

使用volatile可以保证可见性。

当一个变量使用volatile修饰时，线程对该变量的修改，回立马回写到主内存，而不只是反映在线程的私有内存中。

### 顺序性

顺序性指的是，程序执行的顺序按照代码的先后顺序执行。

以下面这段代码为例

```
boolean started = false; // 语句1
long counter = 0L; // 语句2
counter = 1; // 语句3
started = true; // 语句4
```

从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。

处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。

CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。


##### 如何保证顺序性

编译器和处理器对指令进行重新排序时，会保证重新排序后的执行结果和代码顺序执行的结果一致，所以重新排序过程并不会影响单线程程序的执行，却可能影响多线程程序并发执行的正确性。

Java中可通过volatile在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。

synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。

除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为happens-before原则隐式地保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。